# SSCalendar - Data Flow Documentation

## Authentication Flow

1. User clicks "Sign in with Google" on LoginPage
2. Google OAuth popup opens
3. User authenticates with Google
4. Google returns ID token to client
5. Client sends token to POST /api/auth/google
6. Server verifies token with Google
7. Server finds/creates user in MongoDB
8. Server logs login action
9. Server returns JWT token + user data
10. Client stores JWT in localStorage
11. Client redirects to Dashboard

## Event Creation Flow

1. User clicks "Create Event" button
2. EventDialog opens with empty form
3. User fills event details (title, date, time, etc.)
4. User submits form
5. Client validates form data
6. Client sends POST /api/events with JWT header
7. Server validates JWT and extracts user ID
8. Server creates Event document in MongoDB
9. Server logs event creation action
10. Server returns created event data
11. Client updates local events state
12. Calendar grid re-renders with new event
13. EventDialog closes

## Event Display Flow

1. User navigates to calendar month
2. CalendarContext triggers fetchEvents()
3. Client calculates date range (month Â± 7 days)
4. Client sends GET /api/events with date range
5. Server queries events for user within date range
6. Server returns filtered events array
7. Client updates events state
8. CalendarGrid component re-renders
9. getEventsForDate() filters events per day
10. Event chips display on calendar cells

## Event Update Flow

1. User clicks on existing event
2. EventDialog opens with pre-filled data
3. User modifies event details
4. User submits form
5. Client sends PUT /api/events/:id with changes
6. Server validates ownership and updates document
7. Server logs event update action
8. Server returns updated event data
9. Client updates local events state
10. Calendar re-renders with changes

## Search Flow

1. User enters search query in Search component
2. User applies optional filters (date, group)
3. Client sends GET /api/search with parameters
4. Server builds MongoDB query with filters
5. Server executes text search on title/description
6. Server returns matching events (max 100)
7. Client displays results in list format
8. User clicks result to navigate to Events tab

## JSON Upload Flow

1. User clicks "Upload JSON" button
2. Upload dialog opens with textarea
3. User pastes JSON event data
4. User clicks "Upload" button
5. Client validates JSON format
6. Client sends POST /api/events/upload
7. Server validates each event object
8. Server creates multiple Event documents
9. Server logs JSON upload action
10. Server returns created events array
11. Client merges new events with existing state
12. Calendar updates to show new events

## User Management Flow (Admin)

1. Admin navigates to Users tab
2. Client sends GET /api/users
3. Server checks admin role permission
4. Server returns all users from database
5. Admin clicks activate/deactivate button
6. Client sends PATCH /api/users/:id
7. Server updates user active status
8. Server deactivates user's events if needed
9. Server logs admin action
10. Client updates user list display

## Notification Generation Flow

1. NotificationContext monitors events state
2. System filters events for next 7 days
3. System identifies high-priority (next day) events
4. System checks for repeating events
5. System generates notification objects
6. System sorts by priority and date
7. Notifications component displays list
8. User can toggle repeat settings
9. Changes trigger event update flow

## Logging Flow

1. Any significant action occurs (login, CRUD, admin)
2. Server creates Log document with:
   - User ID reference
   - Action type enum
   - Description string
   - Metadata object
   - Timestamp
3. Log saved to MongoDB logs collection
4. Admin can view logs via GET /api/logs
5. Logs filtered by action, user, date range
6. Results displayed in chronological order

## Error Handling Flow

1. Error occurs in client or server
2. Server errors logged to console
3. Server returns appropriate HTTP status
4. Client catches error in try/catch blocks
5. Client displays user-friendly error message
6. Client maintains application state
7. User can retry failed operations

## State Management Flow

1. AuthContext manages user authentication state
2. CalendarContext manages events and calendar state
3. Components subscribe to context changes
4. State updates trigger re-renders
5. Local storage persists JWT token
6. Page refresh restores authentication state

## Database Schema Relationships

Users Collection:
- _id (ObjectId) - Primary key
- googleId (String) - Google OAuth ID
- email (String) - Unique identifier
- role (String) - user|admin permissions

Events Collection:
- _id (ObjectId) - Primary key
- userId (ObjectId) - References Users._id
- date (Date) - Event date for queries
- repeat (Object) - Repeat configuration

Logs Collection:
- _id (ObjectId) - Primary key
- userId (ObjectId) - References Users._id
- action (String) - Enum of action types
- timestamp (Date) - For chronological sorting

## Security Flow

1. All API routes protected by authenticateToken middleware
2. JWT token validated on each request
3. User object attached to request
4. Admin routes have additional requireAdmin check
5. Database queries filtered by user ownership
6. Rate limiting prevents abuse
7. CORS configured for client domain only
8. Helmet adds security headers